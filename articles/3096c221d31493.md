---
title: "Rustã§TOTP(Time-based One-Time Password)ã‚’ã€RFCã ã‘è¦‹ã¦åŸç†åŸå‰‡ã‹ã‚‰å®Ÿè£…ã™ã‚‹"
emoji: "ğŸ¦€"
type: "tech"
topics: ["rust", "ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ", "totp"]
published: true
---

å…ˆã«æˆæœç‰©ã¯ã“ã¡ã‚‰ã§ã™ã€‚
https://github.com/ulwlu/rust-totp

**çµŒç·¯**ï¼šã²ã‚‡ã‚“ãªãã£ã‹ã‘ã§ TOTP ã®å®Ÿè£…æ©Ÿä¼šãŒã‚ã£ãŸã€‚RFC æ–‡æ›¸ã‹ã‚‰ã¯ 0â†’1 ã§ã‚³ãƒ¼ãƒ‰å®Ÿè£…ã—ãŸçµŒé¨“ãªã„ã®ã§ã€ã›ã£ã‹ããªã®ã§ RFC ã ã‘è¦‹ã¦ Rust ã§å®Ÿè£…ã™ã‚‹äº‹ã«ã—ãŸã€‚

**æ¦‚è¦**ï¼šOATH ã‚„ 2FA ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ã€TOTP(Time-based One-Time Password)ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æ¦‚å¿µã¨å®Ÿè£…ã‚’ãƒ¡ãƒ¢ã€‚[RFC6238](https://tools.ietf.org/html/rfc6238)æº–æ‹ ã€‚

**å˜èª**ï¼š

- **TOTP**: 2011 å¹´ã« HOTP ã®æ‹¡å¼µã¨ã—ã¦èª•ç”Ÿã€‚RFC6238 æº–æ‹ ã€‚ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼†ã‚µãƒ¼ãƒãƒ¼é–“ã§å…±æœ‰ã•ã‚Œã¦ã‚‹ç§˜å¯† tokenã€æ™‚é–“æƒ…å ±ã€ã‚’ã‚‚ã¨ã« OTP ã‚’ç”Ÿæˆã™ã‚‹ã€‚HOTP ã¨é•ã£ã¦æ™‚é–“æƒ…å ±ã‚’ã‚‚ã¨ã«ã™ã‚‹ã‹ã‚‰ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹ã«å¯¾ã™ã‚‹é˜²å¾¡åŠ›ã¯å¼·ã„ã€‚å‹¿è«–ã‚­ãƒ¼ãƒ­ã‚¬ãƒ¼ãªã©ã•ã‚ŒãŸã‚‰å³æ­»ã€‚ã¾ãŸã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã¨é€šä¿¡ã—ãªãŒã‚‰æ™‚åˆ»ã‚’èª¿æ•´ã§ãã‚‹æ­£ç¢ºãªã‚¯ãƒ­ãƒƒã‚¯ãŒå†…è”µã•ã‚Œã¦ã„ã‚Œã°å•é¡Œãªã„ãŒã€ãã†ã§ãªã„ã‚µãƒ¼ãƒãƒ¼ã®å ´åˆã‚‚ã‚ã‚Šãˆã‚‹ã®ã§ã€RFC ã§ã¯è¨±å®¹å¹…ã«ã¤ã„ã¦è¨€åŠã—ã¦ãŠã‚Šã€ä¸€åº¦ãã®è¨±å®¹å¹…ã‚’è¶…ãˆãŸå ´åˆã¯æ¬¡å›ä»¥é™ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¯ã«ãã®å¹…ã‚’è¨˜éŒ²ã™ã‚‹æ–¹æ³•ãªã©ãŒææ¡ˆã•ã‚Œã¦ã„ã‚‹ã€‚
- **HOTP**: 2005 å¹´ã«èª•ç”Ÿã€‚[RFC4226](https://tools.ietf.org/html/rfc4226)æº–æ‹ ã€‚ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼†ã‚µãƒ¼ãƒãƒ¼é–“ã§å…±æœ‰ã•ã‚Œã¦ã‚‹ç§˜å¯† tokenã€èªè¨¼å›æ•°ã€ã‚’ã‚‚ã¨ã« OTP ã‚’ç”Ÿæˆã™ã‚‹ã€‚TOTP ã¨æ¯”è¼ƒã—ã¦æ±ºå®šçš„ãªè‡´å‘½ç‚¹ãŒã‚ã‚Šã€OTP ãŒä½¿ç”¨ã•ã‚Œãªã„é™ã‚Šæ›´æ–°ã•ã‚Œãªã„ãŸã‚ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹ã‚¢ã‚¿ãƒƒã‚¯ã®å±é™ºæ€§ãŒã‚ã‚‹(å½“ç„¶ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å±¤ã§é˜²å¾¡ã™ã‚‹ã¨ã—ã¦ã‚‚)ã€‚ã‚ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼†ã‚µãƒ¼ãƒãƒ¼é–“ã§ã‚«ã‚¦ãƒ³ãƒˆãŒåŒæœŸã—ã¦ãªã‘ã‚Œã°ãªã‚‰ãªã„ã«ã‚‚é–¢ã‚ã‚‰ãšå½“ç„¶é€£æ‰“ãªã©ã«ã‚ˆã‚Šã‚«ã‚¦ãƒ³ãƒˆãŒãšã‚Œã‚‹äº‹ãŒã‚ã‚Šã€ãã®å¯¾ç­–ã¨ã—ã¦ RFC ã«ã‚ã’ã‚‰ã‚Œã¦ã„ã‚‹[å†åŒæœŸæ–¹æ³•(link ã¯ stackexchange)](https://crypto.stackexchange.com/questions/839/how-does-hotp-keep-in-sync)ãŒæ›´ã«ãƒ–ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ã‚¹ã‚¢ã‚¿ãƒƒã‚¯ã®ãƒªã‚¹ã‚¯ã‚’ã‚ã’ã¦ã„ã‚‹ã‚“ã˜ã‚ƒãªã„ã‹ã¨æ€ã‚ã‚Œã‚‹ã€‚ä¸€å¿œã¾ã  Google Authenticator ãªã©ã§ã‚‚é¸ã¹ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãªã®ã§ç¾å½¹ã ãŒã€è‰²ã€…ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç³»è¨˜äº‹èª­ã‚€é™ TOTP ã®æ–¹ãŒæ¨å¥¨ã•ã‚Œã¦ã‚‹ã€‚
- **OTP**: TOTP ã‚„ HOTP ã§ç”Ÿæˆã•ã‚Œã‚‹ One Time Password ãã®ã‚‚ã®ã‚’æŒ‡ã™ã€‚æœ€å° 6 æ¡(RFC4226 æº–æ‹ )
- **hashlib**: hash ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã€‚TOTP ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ sha1 ãªã®ã ãŒã€google ãªã©ã§ã¯ sha512 ãŒç”¨ã„ã‚‰ã‚Œã¦ã„ã‚‹ã‚‰ã—ã„ã€‚å˜ã«æ–‡å­—åˆ—ã‚’ hash åŒ–ã™ã‚‹ã ã‘ãªã‚‰ã“ã‚Œã ã‘ã§ä½œã‚Œã‚‹ã®ã ãŒã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä»˜ãã«ä»Šå›ã¯ã—ãŸã„ã®ã§(tokenã€æ™‚é–“æƒ…å ±)hmac ã«å…¥ã‚Œã‚‹ã€‚
- **hmac**: æŒ‡å®šã—ãŸ hash ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ã£ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸èªè¨¼ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€‚RFC2104 æº–æ‹ ã€‚

# è¦ä»¶

terminology ã®`MUST`, `MUST NOT`, `REQUIRED` ã‚ãŸã‚Šã‚’æ¤œç´¢ã—ã¦ä»Šå›ã®å®Ÿè£…ã«é–¢ä¿‚ã—ãã†ãªã‚‚ã®ã‚’ãƒ¡ãƒ¢ã—ã¦ã„ãã¾ã™ã€‚

https://tools.ietf.org/html/rfc6238

- `The prover (e.g., token, soft token) and verifier (authentication or validation server) MUST know or be able to derive the current Unix time (i.e., the number of seconds elapsed since midnight UTC of January 1, 1970) for OTP generation` â†’ ã€€ unixtime ã¯é¯–ã® GMT ã«åˆã‚ã›ã‚‹æ–¹é‡ã§ã„ã
- `The prover and verifier MUST either share the same secret or the knowledge of a secret transformation to generate a shared secret.` â†’ æœ¬æ¥ã‚¢ãƒ—ãƒªãªã‚‰ QR ã‚³ãƒ¼ãƒ‰ã§æ¸¡ã—ãŸã‚Šã™ã‚‹ã®ã ãŒã€ä»Šå›ã¯è©¦é¨“ç”¨ãªã®ã§å¼•æ•°ã§é©å½“ãªæ–‡å­—åˆ—æ¸¡ã›ã‚‹ã‚ˆã†ã«ã—ã¦ã€é¯–å´ã¯ test ã§å…¥åŠ›ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹
- `The prover and verifier MUST use the same time-step value X` â†’ ã€€ä»Šå›ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® 30 ç§’ã§ã‚„ã‚Šã¾ã™ã€‚
- `The implementation of this algorithm MUST support a time value T larger than a 32-bit integer when it is beyond the year 2038.` â†’ ã€€ã¯ã„ã€‚
- `Implementations MUST extract a 6-digit code at a minimum and possibly 7 and 8-digit code. Depending on security requirements, Digit = 7 or more SHOULD be considered in order to extract a longer HOTP value`ã€€ â†’ ã€€ã¯ã„ã€‚(ã“ã‚Œã¯ RFC4226 HOTP ã®æ–¹ã®è¦ä»¶)

# ã©ã†ä½œã‚‹?

ä¸Šã‹ã‚‰èª­ã‚“ã§ã„ãã¤ã¤ç†è§£ã—ã¾ã™ã€‚

- `we define TOTP as TOTP = HOTP(K, T), where T is an integer and represents the number of time steps between the initial counter time T0 and the current Unix time` â†’ HOTP ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼éƒ¨åˆ†ã‚’æ™‚é–“ã®ã‚‚ã®ã«å¤‰ãˆãŸã®ãŒ TOTP
- `The definition of HMAC requires a cryptographic hash function, which we denote by H, and a secret key K.` â†’ ã“ã‚Œã¯ RFC2104 ã®èª¬æ˜ã€‚K ã¯ç§˜å¯†éµã€‚ä»Šå›ã¯é©å½“ã«æ±ºã‚ã‚‹ã€‚
- `More specifically, T = (Current Unix time - T0) / X`
- `T0 is the Unix time to start counting time steps (default value is 0, i.e., the Unix epoch)`
- `X represents the time step in seconds (default value X = 30 seconds)` â†’ T ã®å€¤ã®ç®—å‡ºã¯ç°¡å˜ã«ã§ããã†ã€‚
- `Due to network latency, the gap (as measured by T, that is, the number of time steps since T0) between the time that the OTP was generated and the time that the OTP arrives at the receiving system may be large.`
- `We RECOMMEND that at most one time step is allowed as the network delay` â†’ 1 å›åˆ†ã®é…å»¶ã‚’è¨±å®¹ã—ã¦ã„ã¾ã™ã€‚å†’é ­ã§ã‚‚æ›¸ãã¾ã—ãŸãŒ time step window ã‚’ä¼¸ã°ã™ã»ã©ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šè„†å¼±æ€§ã‚’å¤§ãããªã£ã¦ã„ãã¾ã™ã€‚ä»Šå›ã¯åŠ å‘³ã—ã¾ã›ã‚“ã€‚

HOTP ã®æ‹¡å¼µã¨ã—ã¦ã® TOTP å´ã®è€ƒæ…®ã¯ã‚ã‚‹ç¨‹åº¦ã‚ã‹ã£ãŸã®ã§ã€æ¬¡ã« RFC4226 ã‚’è¦‹ã¦ HOTP ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£…æ–¹é‡ã‚’è¦‹ã¦ã„ãã¾ã™

https://tools.ietf.org/html/rfc4226

- `A string always means a binary string, meaning a sequence of zeros and ones.`
- `T: throttling parameter: the server will refuse connections from a user after T unsuccessful authentication attempts` ã“ã‚Œã¯ä»Šå›ç„¡è¦–ã—ã¾ã™
- `s: resynchronization parameter: the server will attempt to verify a received authenticator across s consecutive counter values` â†’ ã“ã‚Œã¯ä»Šå›ç„¡è¦–ã—ã¾ã™
- `As the output of the HMAC-SHA-1 calculation is 160 bits, we must truncate this value to something that can be easily entered by a user` â†’ ã€€å˜ç´”ã« hmac ã§ãƒ¡ãƒƒã‚»èªè¨¼ã™ã‚‹ã ã‘ã§ãªãã€truncate ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚

```bash
We can describe the operations in 3 distinct steps:

   Step 1: Generate an HMAC-SHA-1 value Let HS = HMAC-SHA-1(K,C)  // HS
   is a 20-byte string

   Step 2: Generate a 4-byte string (Dynamic Truncation)
   Let Sbits = DT(HS)   //  DT, defined below,
                        //  returns a 31-bit string

   Step 3: Compute an HOTP value
   Let Snum  = StToNum(Sbits)   // Convert S to a number in
                                    0...2^{31}-1
   Return D = Snum mod 10^Digit //  D is a number in the range
                                    0...10^{Digit}-1
```

```bash
DT(String) // String = String[0]...String[19]
     Let OffsetBits be the low-order 4 bits of String[19]
     Offset = StToNum(OffsetBits) // 0 <= OffSet <= 15
     Let P = String[OffSet]...String[OffSet+3]
     Return the Last 31 bits of P
```

- â†“ ã€€ â†“
- â‘ HMAC çµæœã® 20byte å€¤ã‹ã‚‰ã€å‹•çš„ãƒã‚¤ãƒŠãƒªå¤‰æ›ã—ã¦ä¸‹ä½ 4bit ã‚’å–å¾—ã€‚
- â‘¡â‘  ã‚’ã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ã—ã¦ã€æ›´ã« HMAC çµæœã‹ã‚‰ offset bit - offset + 3 bit ã‚’å–ã‚Šå‡ºã™ã€‚
- â‘¢â‘¡ ã®å¾Œã‚ã‹ã‚‰ 31bit ã‚’å–å¾—ã™ã‚‹ã€‚
- â‘£ ã“ã‚ŒãŒ OTP ã§(31bit ãªã®ã§æœ€å¤§ 2147483648)ã€å¾Œã¯æŒ‡å®šã®æ¡æ•°ã§è½ã¨ã™ã€‚ï¼ˆã“ã‚Œè¦‹ã¦æ°—ã¥ã„ãŸã‘ã©ã€è¨˜è¼‰ã¯ãªã„ãŒ HOTP ã® RFC æ°´æº–ã§è€ƒãˆã‚‹ã¨ digit æœ€å¤§ã¯å®Ÿè³ª 10 ãªã®ã ã¨æ€ã‚ã‚Œã‚‹ï¼‰
- ã¡ãªã¿ã«ã‚µãƒ³ãƒ—ãƒ«ã® `public static byte[] hmac_sha1`ã€€ã‚’è¦‹ã‚‹ã¨ã‚ã‹ã‚Šã¾ã™ãŒã€key ãŒ secret ã§ã€æ‰¿èªç”¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒ counter/æ™‚é–“æƒ…å ±ã§ã™(RFC4226 ã®æ–¹)ã€‚

ã‚ã‚‹ç¨‹åº¦ã‚ã‹ã£ãŸã®ã§ã¾ã¨ã‚ã¾ã™ã€‚

# ã¨ã‚Šã‚ãˆãšã¾ã¨ã‚ãŸå…¨ä½“å›³

![nya](https://storage.googleapis.com/zenn-user-upload/muhbrd8yqzktq8fjta1dv723q83p)

Thanks: [draw.io](https://app.diagrams.net/)

# å®Ÿè£…

å¤§ä½“ä¸‹è¨˜ã®å®Ÿè£…ã§è‰¯ã•ãã†ã€‚

- TOTP
  - generate_otp (secret, time_step, time_offset, digit, digest)
  - generate_counter(time_step, time_offset)
  - ã‚‚ã— time-step window ã‚„ã‚‹ãªã‚‰ now ã¨ at ã¿ãŸã„ãªé–¢æ•°ã‚‚å¿…è¦ã¨æ€ã†(ä½•å€‹å‰ã®ã€ã¨ã„ã†æŒ‡å®šãŒå¿…è¦ãªã®ã§)ã€‚
- HOTP (æœ¬æ¥åˆ¥ãªã®ã§)
  - generate_hasher(secret, counter(TOTP ãªã®ã§æ™‚é–“æƒ…å ±ã ãŒã€hotp ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ è‡ªä½“ã¯ã‚«ã‚¦ãƒ³ãƒˆã‚’ç”¨ã„ã‚‹ç‰©ãªã®ã§åç§°ã¯ã“ã‚ŒãŒè‰¯ã•ãã†), digest)
  - truncate_hasher(hasher)

## å‚™è€ƒ

Rust ã® hash/hmac ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã„ãã¤ã‹ã‚ã‚‹ã®ã§ã™ãŒã€rust-postgres ã§å®Ÿç¸¾ã®ã‚ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’é¸å®šã—ã¾ã—ãŸã€‚rust-crypto ã¯ 2016 å¹´ãŒæœ€çµ‚æ›´æ–°ãªã®ã§ã‚„ã‚ã¾ã—ãŸã€‚
ã¾ãŸã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ derive(Default)ã—ã¦

```rust
impl Default for HotpCounterElement {
  fn default() -> Self {
    HotpCounterElement {
      time_step: 30,
      time_offset: 0,
    }
  }
}
```

ã¿ãŸã„ãª struct ä½œã‚ã†ã‹ã¨æ€ã„ã¾ã—ãŸãŒã€cli ã§ãƒ•ãƒªãƒ¼ãƒã‚§ãƒƒã‚¯ã¨ã‹ã—ãŸã„ã®ã§æ…£ã‚Œã¦ã‚‹ structopt ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯å…¨ã¦å…¥ã‚Œã¾ã—ãŸã€‚
ã‚ã¨åŸç†ç†è§£ãŒç›®çš„ã‹ã¤ç¬¬ä¸€ã ã£ãŸã®ã§ãƒ‘ãƒƒã¨æ›¸ãã¾ã—ãŸãŒã€ä½œã‚Šæ–¹é§„ç›®ã ã‚ˆã£ã¦å ´åˆã¯ã‚³ãƒ¡ãƒ³ãƒˆã«ã¦ã”æŒ‡æ‘˜ãã ã•ã„ã€‚

ã§ã¯ã¾ãšç°¡å˜ãã†ãª TOTP ã® counter ã‹ã‚‰ä½œã‚Šã¾ã—ã‚‡ã†ã€‚

```rust
fn generate_counter(time_step: u64, time_offset: u64) -> [u8; 8] {
  let current_time = SystemTime::now()
    .duration_since(UNIX_EPOCH)
    .unwrap()
    .as_secs();
  let counter = (current_time - time_offset) / time_step;
  let mut unpacked_counter = [0; 8];
  BigEndian::write_u64(&mut unpacked_counter, counter);

  unpacked_counter
}
```

hmac ã¸æ¸¡ã™ã‚­ãƒ¼ã¯ u8 ãªã®ã§ã€è¨ˆç®—å¾Œã« unpack ã—ã¦ã„ã¾ã™ã€‚ã“ã“ã¯ç°¡å˜ã§ã™ã­ã€‚

TOTP ã¯ã“ã® counter ã¨ä»–æƒ…å ±ã‚’ HOTP ã«ã‚ãŸã™ã ã‘ã®å½¹ç›®ãªã®ã§ã€æ¬¡ã« HOTP ã®å®Ÿè£…ã‚’ã—ã¾ã™ã€‚ã¾ãš hasher ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ã‚’ä½œæˆã—ã¾ã™ã€‚ã“ã“ã§ sha1, sha256, sha512 ã‚’ã„ã„æ„Ÿã˜ã«åˆ‡ã‚Šåˆ†ã‘ãŸã„ã®ã§ã™ãŒã€sha1 ã ã‘åˆ¥ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§å‹ãŒé•ã†ã®ã§ã¡ã‚‡ã£ã¨ã†ã¾ãæ›¸ã‘ãªã„ã‹æ‚©ã¿ã¾ã—ãŸã€‚æœ€çµ‚çš„ã« enum ã§ match ã•ã›ã¾ã—ãŸã€‚

```rust
pub enum HashType {
  Sha1,
  Sha256,
  Sha512,
}

enum HashReceiver {
  Sha1([u8; 20]),
  Sha256(Box<Hmac<Sha256>>),
  Sha512(Box<Hmac<Sha512>>),
}

fn generate_hasher(secret: &[u8], counter: &[u8], digest: HashType) -> Vec<u8> {
  let hmac = match digest {
    HashType::Sha1 => HashReceiver::Sha1(hmac_sha1(secret, counter)),
    HashType::Sha256 => HashReceiver::Sha256(Box::new(
      Hmac::<Sha256>::new_varkey(secret).expect("HMAC is able to accept all key sizes"),
    )),
    HashType::Sha512 => HashReceiver::Sha512(Box::new(
      Hmac::<Sha512>::new_varkey(secret).expect("HMAC is able to accept all key sizes"),
    )),
  };

  // hasher is surely 20 byte sized, but hmac lib returns unsized.
  match hmac {
    HashReceiver::Sha1(hmac) => hmac.to_vec(),
    HashReceiver::Sha256(mut hmac) => {
      hmac.update(counter);
      hmac.finalize().into_bytes().to_vec()
    }
    HashReceiver::Sha512(mut hmac) => {
      hmac.update(counter);
      hmac.finalize().into_bytes().to_vec()
    }
  }
}
```

Box ã‚’å…¥ã‚Œã¦ã„ã‚‹ã®ã¯å·¨å¤§ã™ãã‚‹ç‚ºã§ã™ã€‚Box ã‚’å…¥ã‚Œã‚‹äº‹ã§ã‹ãªã‚Šã®å®¹é‡å‰Šæ¸›ã«ãªã‚Šã¾ã™(ã“ã‚Œã¯ clippy ã§è¦‹ã¤ã‘ã‚‹äº‹ãŒã§ãã¾ã™)ã€‚ã“ã‚Œã€ã‚‚ã— 256 ã¨ 512 ã—ã‹ç„¡ã„å ´åˆã¯ `HMAC::<T>` ã¨ã‹ã§ã‚¹ãƒãƒ¼ãƒˆã«ã‹ã‘ã‚‹ã®ã‹ãªãƒ»ãƒ»ãƒ»ã¨ã‹å°‘ã—èª¿ã¹ã¾ã—ãŸãŒã€ã†ã¾ãã„ã‹ãšãã®ã¾ã¾æ›¸ãã¾ã—ãŸï¼ˆã©ã®ã¿ã¡ä»Šå›ã¯ï¼‘ã‚‚è€ƒæ…®ã™ã‚‹ã—ï¼‰ã€‚å‹æ¯ã« impl ã—ã¦ã€generics ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ã¨ã„ã†æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ãŒãã¡ã‚‰ã¯è¨˜è¿°ãŒé•·ã„ã®ã§ã‚„ã‚ã¾ã—ãŸã€‚ã©ã£ã¡ã®æ–¹ãŒå¥½ã¾ã—ã„ã®ã‹ã¯ã‚ˆãã‚ã‹ã£ã¦ãªã„ã§ã™ãŒ enum ã®æ–¹ãŒç›®çš„ãŒæ˜ç¤ºåŒ–ã•ã‚Œã¦ã¦è‰¯ã„ã®ã§ã¯ãªã„ã‹ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

ã¾ãŸã‚³ãƒ¡ãƒ³ãƒˆã«è¨˜è¼‰ã—ã¦ã„ã¾ã™ãŒ hmac.finalize().into_bytes()ã—ãŸçµæœã¯ unsized ã§ã™ã€‚ä¸€æ–¹ hmac_sha1 ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã¡ã‚ƒã‚“ã¨ã‚µã‚¤ã‚ºæ±ºã‚ã¦ãã‚Œã¦ã‚‹ã®ã§ã‚ã‚ŠãŒãŸã„ã€‚

æ¬¡ã« Truncate éƒ¨åˆ†ã‚’å®Ÿè£…ã—ã¾ã™ã€‚è¨ˆç®—ç®‡æ‰€ãŒéå¸¸ã«è¤‡é›‘ã‹ã¤ã€ã“ã“ãŒ HOTP ã®è‚ãªã®ã§ã‚³ãƒ¡ãƒ³ãƒˆã§èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚å†…å®¹ã¯å…ˆç¨‹æ›¸ã„ãŸé€šã‚Šã§ã™ã€‚

```rust
fn truncate_hasher(hasher: &[u8], digits: u32) -> u64 {
  // offset_bit is the decimal number of the last 4 bits of hasher.
  let offset_bit = (hasher[hasher.len() - 1] & 0xf) as usize;
  let mut hasher_partial_value = 0u64;
  // ex.) hasher_partial_value
  // if offset = 10, and
  // hasher[10] = 0x99, hasher[11] = 0x88, hasher[12] = 0x77, hasher[13] = 0x66,
  // you want to get the decimal number of 0x99887766.
  hasher_partial_value += (hasher[offset_bit] as u64) << (24 as u64);
  hasher_partial_value += (hasher[offset_bit + 1] as u64) << (16 as u64);
  hasher_partial_value += (hasher[offset_bit + 2] as u64) << (8 as u64);
  hasher_partial_value += hasher[offset_bit + 3] as u64;
  // otp is the decimal number of the last 32bits of hasher_partial_value.
  let otp = hasher_partial_value & 0x7fffffff;

  otp % 10_u64.pow(digits)
}
```

python ã¨ã‹ã ã¨ç¶ºéº—ã«`hasher[offset_bit:offset_bit+4]`ã¨ã‹ã§ä¸€æ°—ã«å–å¾—ã§ãã‚‹ã¿ãŸã„ã§ã™ã€‚Rust ã¯ã§ããªã„ï¼ˆã¨æ€ã‚ã‚Œã‚‹ã€å¾Œã‹ã‚‰è‰²ã€…èª¿ã¹ãŸã‘ã©ç„¡ç†ãã†ï¼‰ãªã®ã§ã€æ„šç›´ã«è¶³ã—ã¦ã„ãã¾ã™ã€‚

ã“ã“ã¾ã§ãã¦å‹•ä½œç¢ºèªã§ããŸã‚‰ã€ãŠã¾ã‘ã¨ã„ã£ã¦ã¯ãªã‚“ã§ã™ãŒãƒ•ãƒªãƒ¼ãƒã‚§ãƒƒã‚¯ã—ã‚„ã™ã„ã‚ˆã†ã« Structopt ã‚‚ã„ã‚Œã¾ã—ã‚‡ã†ã€‚

```rust
#[derive(StructOpt, Debug)]
#[structopt(
  name = "rust-totp",
  about = "Implementation of totp in Rust",
  setting(ColorAlways),
  setting(ColoredHelp),
  after_help = "This is just for personal use."
)]
struct Opt {
  #[structopt(long = "secret")]
  pub secret: String,

  #[structopt(long = "timestep", default_value = "30")]
  pub time_step: u64,

  #[structopt(long = "offset", default_value = "0")]
  pub time_offset: u64,

  #[structopt(long = "digits", default_value = "6")]
  pub digits: u32,

  #[structopt(long = "digest", default_value = "512")]
  pub digest: u64,
}
```

ã‚³ãƒ¡ãƒ³ãƒˆã«ã‚‚è¨˜è¼‰ã—ã¦ã¾ã™ãŒã€clap ã® arg_enum ä½¿ã†ã¨ possible_values ã‚‚æŒ‡å®šã§ãã¾ã™ã€‚ã¡ã‚‡ã£ã¨å†—é•·ã«ãªã‚‹ã®ã§ä»Šå›ã¯ã‚„ã£ã¦ã¾ã›ã‚“ãŒã€digest ã¨ã‹ã¯ï¼“ç¨®é¡ã—ã‹ãªã„ã‹ã‚‰ã‚„ã£ã¦ã‚‚ã‚ˆã‹ã£ãŸã‹ã‚‚ã€‚

å‹•ä½œç¢ºèªã—ã¦ã¿ã‚‹ã¨ â†“

![nya](https://storage.googleapis.com/zenn-user-upload/2n9pu05hosv1j8vyfsl754bvi5cj)
![nya](https://storage.googleapis.com/zenn-user-upload/z41irtpupqmbf8jsa58cel30ceoc)

æœŸå¾…ã—ãŸé€šã‚Šã§ãã¦ã¾ã™ã­ã€‚30 ç§’å¾…ã£ã¦ã‚‚ OTP ã¯æ›´æ–°ã•ã‚Œãšã€unix0 ã‹ã‚‰ 30 åŒºåˆ‡ã‚Šã®åŸºæº–ã‚’è¶…ãˆã‚‹ã¨ OTP ãŒæ›´æ–°ã•ã‚Œã‚‹äº‹ã‚’ç¢ºèªã§ãã¾ã™ã€‚è‰¯ã•ãã†ãªã®ã§ justfile ã¨ãƒ†ã‚¹ãƒˆã‚‚è¿½åŠ ã—ã¦ã„ãã¾ã—ã‚‡ã†ã€‚ã‚ã‚ŠãŒãŸã„äº‹ã«[RFC ã§ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹](https://tools.ietf.org/html/rfc4226#page-32)ã‚’ç”¨æ„ã—ã¦ãã‚Œã¦ã„ã¾ã™ã€‚ç°¡å˜ã«ã§ã™ãŒã€RFC ã§ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿éƒ¨åˆ†ã®ã¿ãƒ†ã‚¹ãƒˆã‚’ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```rust
#[test]
fn test_generate_otp() {
  // test values from RFC 4226
  // https://tools.ietf.org/html/rfc4226#page-32
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 0], 6, HashType::Sha1), 755224);
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 1], 6, HashType::Sha1), 287082);
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 2], 6, HashType::Sha1), 359152);
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 3], 6, HashType::Sha1), 969429);
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 4], 6, HashType::Sha1), 338314);
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 5], 6, HashType::Sha1), 254676);
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 6], 6, HashType::Sha1), 287922);
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 7], 6, HashType::Sha1), 162583);
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 8], 6, HashType::Sha1), 399871);
  assert_eq!(generate_otp(b"12345678901234567890", &[0, 0, 0, 0, 0, 0, 0, 9], 6, HashType::Sha1), 520489);
}
```

```make
format:
  cargo fmt --all

lint:
  cargo clippy

test:
  cargo test

build:
  cargo build --release

all: format lint test build
```

å‹•ä½œç¢ºèªã™ã‚‹ã¨ â†“

![nya](https://storage.googleapis.com/zenn-user-upload/oxc6e50ew81t2nkorj0hf8sk53wc)

æ­£å¸¸å‹•ä½œã—ã¦ã„ã¾ã™ã­ã€‚

ã“ã‚Œã«ã¦å®Ÿè£…çµ‚ã‚ã‚Šã§ã™ã€‚æ”¹ã‚ã¦æˆæœç‰©ã¯ã“ã¡ã‚‰ã€‚

https://github.com/ulwlu/rust-totp

# ã¾ã¨ã‚

wikiï¼†è«–æ–‡ã‹ã‚‰è‡ªåˆ†ã§ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…ã¨ã„ã†ã®ã¯ 2 å›çµŒé¨“ã‚ã£ãŸã®ã§ã™ãŒã€RFC ã¯å›³ãŒã»ã¼ç„¡ãã¦ã€ã“ã“ã‹ã‚‰å®Ÿè£…ã™ã‚‹ã®ã¯ãªã‹ãªã‹ä½“åŠ›ã„ã‚Šã¾ã—ãŸã€‚ã“ã®ãã‚‰ã„ã®é‡é‡ã®å®Ÿè£…ã‚’ãƒãƒ³ãƒãƒ³ã“ãªã—ã¦ã€å®Ÿè£…åŠ›ã¨ã„ã†ã‹å®Ÿè£… HP/MP ã¨ã„ã†ã‹ã€ä½•ã§ã‚‚æ¥ã„ãã‚‰ã„ã«ãªã‚Œã‚‹ã‚ˆã†ç²¾é€²ç²¾é€²ã€‚

**ã¡ãªã¿ã«**ï¼šã‚ã¨ã‹ã‚‰ä»–ã®äººã®å®Ÿè£…è¦‹ã¦ã¾ã—ãŸãŒã€[ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰æ§˜ã®å¥¥æ§˜ã®è¨˜äº‹](https://dev.classmethod.jp/articles/totp-implementation-pure-python/)ã®ãŒæ»…èŒ¶è‹¦èŒ¶ã‚ã‹ã‚Šã‚„ã™ã‹ã£ãŸã§ã™ã€‚
