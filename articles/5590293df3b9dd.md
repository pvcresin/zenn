---
title: 'AtCoder: L - Interactive Sortingã‚’åŠ›æŠ€ã§ãªãFord-Johnson Algorithmã§æœ€é€Ÿã§è§£ã'
emoji: 'ğŸ¡'
type: 'tech'
topics: ['python', 'ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°', 'atcoder', 'ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ']
published: true
---

:::message
Ford Johnson Algorithm ã®å®Ÿè£…ã‚³ãƒ¼ãƒ‰ãŒ Python ã§ã¯åˆã‚ã¦ã‚‰ã—ãã€Algorithms/Python ã« PR ãŒãƒãƒ¼ã‚¸ã•ã‚Œã¾ã—ãŸ
:::

https://github.com/TheAlgorithms/Python/pull/2211

---

ã€å•é¡Œã€‘
https://atcoder.jp/contests/language-test-202001/tasks/practice_2

ã€å®Ÿè£…ã€‘
ãƒ»ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ 1, 2 : ãƒãƒ¼ã‚¸ã‚½ãƒ¼ãƒˆã§å®Ÿè£…
ãƒ»ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ 3 : Ford-Johnson Algorithm(merge insert sort)ã§å®Ÿè£…

ã€ã‚³ãƒ¼ãƒ‰ã€‘

```python
N, Q = map(int, input().split())
S = [chr(ord('A') + i) for i in range(N)]

def compare(a, b):
  print("?", a, b, flush=True)
  return input()

# ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1, 2
def merge_sort(collection):
  def merge(left, right):
    result = []
    while left and right:
      if compare(left[0], right[0]) == "<":
        result.append(left.pop(0))
      else:
        result.append(right.pop(0))
    return result + left + right

  length = len(collection)
  if length <= 1:
    return collection
  middle = length // 2
  return merge(merge_sort(collection[:middle]), merge_sort(collection[middle:]))

# ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3
def merge_insertion_sort(collection):
  def binary_search_insertion(sorted_list, item):
    left = 0
    right = len(sorted_list) - 1
    while left <= right:
      middle = (left + right) // 2
      if left == right:
        if compare(sorted_list[middle], item) == "<":
          left = middle + 1
          break;
        else:
          break;
      elif compare(sorted_list[middle], item) == "<":
        left = middle + 1
      else:
        right = middle - 1
    sorted_list.insert(left, item)
    return sorted_list

  def sortlist_2d(list_2d):
    def merge(left, right):
      result = []
      while left and right:
        if compare(left[0][0], right[0][0]) == "<":
          result.append(left.pop(0))
        else:
          result.append(right.pop(0))
      return result + left + right

    length = len(list_2d)
    if length <= 1:
      return list_2d
    middle = length // 2
    return merge(sortlist_2d(list_2d[:middle]), sortlist_2d(list_2d[middle:]))

  if len(collection) <= 1:
    return collection

  two_paired_list = []
  is_surplus    = False
  for i in range(0, len(collection), 2):
    if (i == len(collection) - 1):
      is_surplus = True
    else:
      if compare(collection[i], collection[i+1]) == "<":
        two_paired_list.append([collection[i], collection[i+1]])
      else:
        two_paired_list.append([collection[i+1], collection[i]])
  sorted_list_2d = sortlist_2d(two_paired_list)
  result = [i[0] for i in sorted_list_2d]
  result.append(sorted_list_2d[-1][1])

  if is_surplus:
    pivot = collection[-1]
    result = binary_search_insertion(result, pivot)

  is_surplus_inserted_before_this_index = False
  for i in range(len(sorted_list_2d) - 1):
    if result[i] == collection[-1]:
      is_surplus_inserted_before_this_index = True
    pivot = sorted_list_2d[i][1]
    if is_surplus_inserted_before_this_index:
      result = result[:i+2] + binary_search_insertion(result[i+2:], pivot)
    else:
      result = result[:i+1] + binary_search_insertion(result[i+1:], pivot)

  return result

if len(S) == 5:
  print('!', ''.join(merge_insertion_sort(S)))
else:
  print('!', ''.join(merge_sort(S)))
```

ã€è§£èª¬ã€‘
Ford-Johnson Algorithm ã¯ã€N<11 ã®éš›ã«æœ€é©ã§ã‚ã‚‹ã“ã¨ãŒè¨¼æ˜ã•ã‚Œã¦ã„ã‚‹ã‚½ãƒ¼ãƒˆæ³•ã§ã™ã€‚(å‚ç…§ï¼š https://en.wikipedia.org/wiki/Merge-insertion_sort)
ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ 3 ã¯ãƒãƒ¼ã‚¸ã‚½ãƒ¼ãƒˆã§ã¯è¨ˆç®—é‡ O(n log n)ã§ã€æœ€æ‚ªæ™‚ã« 8 å›å¿…è¦ã¨ãªã‚Šé–“ã«åˆã„ã¾ã›ã‚“ã€‚

ãã“ã§åˆ¥ã®è§£æ³•ãŒå¿…è¦ã¨ãªã‚‹ã®ã§ã™ãŒã€éå»ã®è§£ç­”ã‚„è¨˜äº‹ã§ã¯ if æ–‡ã‚’å¤šé‡ã—ãŸã‚Šã€å…¨çµ„åˆã›ã‚’ permutations ã§å‡ºã—ã¦æ¢ç´¢ã™ã‚‹åŠ›æŠ€ãªè§£æ³•ãŒå¤šã„ã‚ˆã†ã§ã—ãŸã€‚

å®Ÿéš›ã€å…¨ä½“æ•°ãŒ 5 ãªã‚‰è§£æ³•è‡ªä½“ã¯ã™ãã«æ€ã„ã¤ãã®ã§ if æ–‡ã§ã‚‚çªç ´å¯èƒ½ã§ã™

```bash
1. Aã¨Bã‚’æ¯”è¼ƒã€‚å°ã•ã„é †ã«A, Bã¸å†ä»£å…¥ã€‚(max 1å›)
2. Cã¨Dã‚’æ¯”è¼ƒã€‚å°ã•ã„é †ã«C, Dã¸å†ä»£å…¥ã€‚(max 1å›)
3. Aã¨Cã‚’æ¯”è¼ƒã€‚ã“ã®æ™‚A<Cãªã‚‰ã°A<C<Dã€‚(max 1å›)
4. Eã«ã¤ã„ã¦ã€A<C<Då†…ã§ã‚½ãƒ¼ãƒˆ(max 2å›)
5. Bã«ã¤ã„ã¦ã€A<Bã¯é †åº1ã§ç¢ºå®Ÿãªã®ã§ã€[A,C,D,E(é †ã¯ãƒ©ãƒ³ãƒ€ãƒ )]ã®ä¸­ã§Aã‚ˆã‚Šå¤§ãã„ç¯„å›²ã§ã‚½ãƒ¼ãƒˆã€‚(max C,D,Eã®ç¯„å›²ã§ã‚½ãƒ¼ãƒˆã™ã‚‹å ´åˆã®2å›)

1 + 1 + 1 + 2 + 2 = 7ã€‚
```

ã—ã‹ã—æœ¬å•é¡Œã®ã‚±ãƒ¼ã‚¹ã§ã¯ N<11 ãªã®ã§ Ford-Johnson Sort ã‚’ç”¨ã„ã‚‹äº‹ã§è§£æ³•ã§ãã€ã‹ã¤ä¸Šé™æ•°ã‚’ã‚¯ãƒªã‚¢ã§ãã¾ã™ã€‚ã›ã£ã‹ããªã®ã§ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã‚¹ãƒãƒ¼ãƒˆã«è§£ã„ã¦ã¿ã¾ã™ã€‚å‡¦ç†ã®æµã‚Œã¯ä¸‹è¨˜ã®é€šã‚Šã§ã™ã€‚

```bash
1. ï¼’ã¤ãšã¤ã®çµ„åˆã›ã‚’ä½œã‚‹ ä¾‹: [[C, B], [E, D], [F, A], Z] ã“ã®æ™‚Zã¯ä¸€æ—¦å¤–ã™ã€‚
2. ï¼’ã¤ãšã¤ã®çµ„åˆã›ã‚’sortã™ã‚‹ã€€ä¾‹: [[B, C], [D, E], [A, F]]
3. ï¼’ã¤ãšã¤ã®çµ„åˆã›ã®å…ˆç«¯ã‚’sortã™ã‚‹ã€€ä¾‹: [[A, F], [B, C], [D, E]]

ã“ã®æ™‚å›³ã«è¡¨ã™ã¨

  D B A    ã¼ã£ã¡(æ”¾ç½®ä¸­)
  | | |
  E C F    Z

ã¨ãªã£ã¦ã„ã¾ã™ã€‚

4. ä¸Šæ®µã§æœ€å¤§å€¤ã®Dã‚ˆã‚Šã‚‚EãŒå¤§ãã„äº‹ã¯æ‰‹é †2ã§ç¢ºå®Ÿãªã®ã§ã€ä¸Šæ®µã®æœ€å¤§ä½ç½®ã«é…ç½®ã™ã‚‹

  E D B A     ã¼ã£ã¡(æ”¾ç½®ä¸­)
      | |
      C F     Z

5. æ”¾ç½®ä¸­ã®Zã‚’ABDEå†…ã§sortã—ã¾ã™ï¼ˆå›³ã§ã¯æœ€æ‚ªæ™‚ã®å ´åˆã®ã€æœ€å¤§ä½ç½®ã«sortã•ã‚Œã¦ã¾ã™ï¼‰

  Z E D B A
        | |
        C F

6. ä¸Šæ®µæœ€å°ã®Aã®ãƒšã‚¢ã§ã‚ã‚‹Fã«ã¤ã„ã¦ã€A<Fã¯æ‰‹é †2ã§ç¢ºå®Ÿãªã®ã§ã€Aã‚’é™¤ã„ãŸB,D,E,Zå†…ã§sortã—ã¾ã™ï¼ˆå›³ã§ã¯æœ€æ‚ªæ™‚ã®å ´åˆã®ã€æœ€å¤§ä½ç½®ã«sortã•ã‚Œã¦ã¾ã™ï¼‰

  F Z E D B A
          |
          C

7. æ¬¡ã«Bã®ãƒšã‚¢ã§ã‚ã‚‹Cã«ã¤ã„ã¦ã€B<Cã¯æ‰‹é †2ã§ç¢ºå®Ÿãªã®ã§ã€A, Bã‚’é™¤ã„ãŸD,E,Z,Få†…ã§sortã—ã¾ã™

  C F Z E D B A

```

ã“ã®æ‰‹é †ã§å®Œæˆã§ã™ã€‚

ã€å˜ä½“ã¨ã—ã¦ã®æˆæœå“ã€‘
https://github.com/ulwlu/merge_insertion_sort

ãªã«ã‹é–“é•ãˆã‚„ã€æŒ‡æ‘˜ãªã©ã”ã–ã„ã¾ã—ãŸã‚‰æ˜¯éãŠæ•™ãˆãã ã•ã„ã€‚

## Thanks

Clojure ã§æ›¸ã‹ã‚ŒãŸå®Ÿè£…ã€‚ç†è§£ã‚’æ·±ã‚ã‚‹éš›ã«éå¸¸ã«å‚è€ƒã«ãªã‚Šã¾ã—ãŸã€‚ã¡ãªã¿ã«é–“é•ãˆãŒä¸€ç‚¹å®Ÿã¯ã‚ã‚‹ã®ã§ã™ãŒã€ãã®é–“é•ã„ã«ã¤ã„ã¦ã¯ä¸Šè¨˜ã®è‡ªåˆ†ã®ãƒªãƒã‚¸ãƒˆãƒªã§èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚ï¼ˆç”»åƒã®èª¬æ˜ãƒŸã‚¹ãªã®ã§ã€PR ã§ããªã„ãƒ»ãƒ»ãƒ»æ¶™ï¼‰

https://github.com/decidedlyso/merge-insertion-sort
