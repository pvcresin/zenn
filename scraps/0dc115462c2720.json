{
  "title": "Kotlinの勉強メモ",
  "closed": false,
  "archived": false,
  "created_at": "2021-03-07",
  "comments": [
    {
      "author": "ulwlu",
      "created_at": "2021-03-07",
      "body_updated_at": "2021-03-07",
      "body_markdown": "- **経緯:** ひょんなきっかけでKotlin触る事になりそうなので勉強メモ。\n\n- **パッと調べた所感:**\n\n調べるほど結構な会社でWebのバックエンドで使われてるらしい\n（ex: Uzabase, Sansan, Smartnews, Line)。\n\n最近流行の静的型付け言語と大体同じ感じで書ける。\n記述量も少ないしデフォルトimmutableだしJVM関連のエコシステムは非常に充実。\n\nしかしメモリ使用量が多い。\nこれは簡単なhello worldを実測しても、適当なベンチマークサイト見ても明らかに多い。\nそのあたりの節約の知恵（インライン関数を使ってオーバーヘッドを無くすとか、デリゲートプロパティを使わないとかあるらしい。他の言語でもそうだが可変引数を作らないとか）が、結構シニアになっていくのに必要な言語なのかなという感想を抱きました。\n\n- **勉強のゴール:** APIサーバーを作ります。やはり新しい言語勉強する時は一番これがわかりやすい気がします。4月の応用技術の勉強もしてるのでなんかゆっくりペースで。"
    },
    {
      "author": "ulwlu",
      "created_at": "2021-03-07",
      "body_updated_at": "2021-03-07",
      "body_markdown": "## Kotlin + Springboot\n\n- Kotlinにはwebフレームワークが各種あり、KtorとJavalinとSpringbootが有名。Ktor, JavalinはシンプルでGinやFlaskになれてる人ならかなりとっつきやすいと思いました。ただ恐らく実務ではSpringbootの方がJava互換性、普及度から使われてそうなので勉強目的ならこっちが最適だろうと選択。\n- [Spring Initializr](https://start.spring.io/)というサイトからプロジェクトの雛形を作る事を推奨するサイトが多い。これで色々ポチポチしてzipをダウンロードしてIntelliJで開くと勝手にビルドしてくれる。しかし全然自分の理解のためにならなかったので（実用では最初に全部正解がわかってるわけじゃなく、後から入れたい時にローカルから追加する方法を知っとかないと実用的じゃない）、手動で１から作る方法を模索。（ちなみにいつかこのinitializrを使いたいとなった時も、コマンドからできる事がわかった。`curl https://start.spring.io/starter.tgz =d type=gradle-project -d language=kotlin -d baseDir=demo`でskeltonなアプリを作ってくれる。）\n- とりあえずgradleが一番モダンかつ一番評価が高いビルダー＆タスクランナーである事がわかる[vvakameさんの参考記事](https://qiita.com/vvakame/items/83366fbfa47562fafbf4)。Spring Initializrがやっている事は下記の通りだとわかる。\n  - Gradle Initのオプション追加\n  - build.gradleのbuildscriptに必要ライブラリと依存パッケージを記載\n  - build.gradleのsourceCompatibilityにJavaバージョンを指定\n  - settings.gradleにプロジェクトのメタデータを記載\n  - gradleのwrapperを作る。これのバージョンはInitializrでは最新だけが指定されるらしい。手動でやるならbuild.gradleのwrapper.graddle.Versionで指定できる。\n  - IntelliJで開いたら勝手にビルドしてくれる `gradle タスク名`。\n- ここらへんを自分でコマンドでやってみる。gradle initで一発で下の状態まで作ってくれる。create-react-appくらい楽。\n\n![](https://storage.googleapis.com/zenn-user-upload/1g3jgyd0ynpyk3olq3t9tc4n8m9u)\n\n- gradleフォルダにはwrapperがある。これはgradleをインストールしなくてもアプリが使えるようになっている。これだけで6MBもあるのだがgitignoreしない。このバージョンはbuild.gradleで指定できる。\n- `gradlew`はlinux用の起動用スクリプトで、`gradlew.bat`はwindows用。やさしい。単純にgradleでやるよりも、gradleがなかった場合のインストールまでしてくれるのでこっちを使ったほうがいい。./gradlew bootRunみたいな。\n- `.gradle`はgradleの実行環境の実態がドカンとあるのでこれはignoreする。これはpyenvの感覚に近い。\n- このプロジェクト内で下記のようにプロジェクトを分けたいなら、settings.gradle.ktsに`include(\"frontend\", \"backend\")`みたいに書く。これはRustでCargo.tomlに書くworkspaceと似ている。ただこの階層絶対後で鬼のようにファイル増えそうだからsrc内に閉じ込めたほうがよさそう\n\n![](https://storage.googleapis.com/zenn-user-upload/vf2ha1yumsl0k4wfw68zdxcbf6rw)\n\n- Springbootはsrc/main/{kotlin / java}/(ドメイン名を入れたりする。com/googleみたいな。でもいれなくてもいい。)配下に作成していく。なんでこんなドメイン名を入れる構成なんだろ？と思ったらDTOを意識しているらしい[参考記事](https://stackoverflow.com/questions/56964445/what-does-domain-folder-do-in-a-spring-boot-project-and-what-classes-should-be-s)。とはいえ普通はやってないとこの方が多いらしい。\n- エントリーポイントは`@SpringBootApplication`が入ってるコードがそうなる。ここで指定したクラスを`SpringBootApplication.run(main.class)`してるか`org.springframework.boot.runApplication<Class>(opt)`している箇所が自動でエントリポイントになるので、mainじゃなくても適当なコードでもsrc/main/kotlinにいればそこがエントリポイントになる。ただ一番確実なのは`gradlew bootRun`した結果ビルドされる`build/tmp/bootJar/MANIFEST.MF`の、StartClassを見ると一番わかりやすい。\n"
    },
    {
      "author": "ulwlu",
      "created_at": "2021-03-07",
      "body_updated_at": "2021-03-08",
      "body_markdown": "\n簡単に動作確認してみる。\n\n```kotlin\n// src/main/kotlin/hoge/Main.kt\n\npackage hoge // package宣言はgoと同じ感じ。同階層のものは同じpackageになる。\n\nimport org.springframework.boot.autoconfigure.SpringBootApplication\n// autoconfigureというのは結構便利なモダンなアノテーションが使えるらしい。\n// というのもこれが無い時代は@Configuration @EnableAutoConfiguration @ComponentScan の３つが必要だったらしい。\n// これらはSpringBootの自動構成、Component Scan、Bean登録、構成クラスの追加とかを行なっている。\n// そしてそれはspringbootの公式ドキュメントの[ベストプラクティス](https://spring.pleiades.io/spring-boot/docs/2.0.6.RELEASE/reference/html/using-boot-structuring-your-code.html)基準\nimport org.springframework.boot.runApplication\n// これはエントリポイントの起動を簡単にしたもの。下記のような記述(Java)のドロップイン置換である。\n// public class Application {\n//    public static void main(String[] args) {\n//      org.springframework.boot.SpringApplication.run(Application.class, args);\n//    }\n//}\n\n// これが自動でエントリポイントでなり、かつこの階層から下をComponentScanでスキャンしていく。\n// ComponentScan対象をずらすには引数にscanBasePackagesと指定しないといけない、がバッドケース？\n@SpringBootApplication\nclass HogeApplication\n\n// アプリが動く。この時点では\nfun main(args: Array<String>) {\n  runApplication<HogeApplication>(*args)\n}\n```\n\n```kotlin\n// build.gradle.kts (これはtop階層のgradleとは別にsrc配下に置くといいかも。topからgradlew :src:bootRunで動く。)\n\n// kotlinのコンパイルタスクを一括DLしてくれる。\n// 下記のtasks.withType<KotlinCompile>がそれ\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\n// 必要なプラグイン\nplugins {\n  // spring boot系\n  id(\"org.springframework.boot\") version \"2.3.5.RELEASE\"\n  // dependenciesで詳細書いてる\n  id(\"io.spring.dependency-management\") version \"1.0.10.RELEASE\"\n  // id(\"org.jetbrains.kotlin.jvm\")と同義。id指定かバイネームも可能かの違い。\n  kotlin(\"jvm\") version \"1.4.10\"\n  kotlin(\"plugin.spring\") version \"1.4.10\"\n}\n\n// プラグインが登録されてるサイト。Rustでいうcrates.ioとかPerlでいうcpanみたいな感じ。\n// maven central以外だとjcenterが有名\nrepositories {\n  mavenCentral()\n}\n\n// プロダクトの一連の依存性バージョンを定義した一覧表。\n// npm-shrinkで全部出てくるやつにイメージは近い。\n// 本来の意味が「バージョン定義表」なのに何故バージョン記載がないのかというと、\n// 昔はMavenの時のpom.xmlの方がこれは記述性が高かったらしく、gradleでもpom.xmlを使って\n// apply plugin: \"io.spring.dependency-management\"して\n// mavenBomをimportすればそれに依存するバージョンは勝手に書いてくれるらしく便利だったらしい。\n// 今は普通にapply pluginでversion指定すれば楽に入る。そういうコードが残ってたら名残と思えばいい。\ndependencies {\n  // これが本当に簡単すぎる。後で書くがjavax.persistenceで記法したEntityに簡単にmigrateしてくれる。\n  implementation(\"org.springframework.boot:spring-boot-starter-data-jpa\")\n  // インメモリデータベース。後でMySQLに変える。\n  runtimeOnly(\"com.h2database:h2\")\n  // https://spring.pleiades.io/guides/gs/accessing-data-rest/　を参考。\n  // なんとEntity作ったらそれ用のapiを勝手に作ってくれる。楽だなー・・・\n  implementation(\"org.springframework.boot:spring-boot-starter-data-rest\")\n  implementation(\"org.springframework.boot:spring-boot-devtools\")\n  // リフレクション機能が使えるようになる。逆にこれデフォルトで使えないんだ・・・\n  // Perlみたいな記法。Student::classみたいな。\n  implementation(\"org.jetbrains.kotlin:kotlin-reflect\")\n  // ほぼ必須、kotlinのスタンダートライブラリの拡張。\n  implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\")\n}\n\ntasks.withType<KotlinCompile> {\n  kotlinOptions {\n    // これはnullの可能性があるアノテーションがあった時コンパイル時にエラーを出してくれるオプション\n    freeCompilerArgs = listOf(\"-Xjsr305=strict\")\n    jvmTarget = \"14\"\n  }\n}\n\n```\n\n```kotlin\n// src/main/kotlin/hoge/Api.kt\n\npackage hoge\n\n//これはインタフェースで、deleteとかfindByIDとか汎用的なCRUD操作が全て詰まっている。\nimport org.springframework.data.repository.CrudRepository\n// これ自体はEnumなんだけど、JavaのEnumはオブジェクトの列挙らしいのでメソッドもあったりする。\n// https://spring.pleiades.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.html\n// 滅茶苦茶あるので上記参照。\nimport org.springframework.http.HttpStatus\n// ほぼ必須。handlerをしてくれる。handlerなのでcookie操作やcors操作もしてくれる。\nimport org.springframework.web.bind.annotation.*\n\n// ORMをアノテーションで完結してくれるすごい人達。\n// あまりに抽象的で最初混乱する。\n// Gormのstructに付け足すタグみたいに考えるとスッキリ理解できる。もちろんリレーションも書ける。\nimport javax.persistence.Entity\nimport javax.persistence.GeneratedValue\nimport javax.persistence.GenerationType\nimport javax.persistence.Id\n\n@Entity\ndata class User(\n  @Id // エンティティのプライマリーキーである事を示す。PKじゃないんだ、という意外。\n  // プライマリーキーにユニークな値を自動で生成してくれる。\n  // Typeに色々設定できて、sequence用もある。今回はautoで良し。\n  @GeneratedValue(strategy = GenerationType.AUTO)\n  val id: Long = 0,\n  val name: String = \"\"\n)\n\ninterface UserRepository : CrudRepository<User, Long>\n\n// このアノテーションは、全てのメソッドがviewの代わりにdomainを返してくれるようにしてくれる。\n// 後でcontrollerとresponseに分けるべきだけど最初はこれでいい。\n@RestController\n@RequestMapping(\"/api/users\")\nclass UserController(private val repository: UserRepository) {\n  @GetMapping\n  fun findAll() = repository.findAll()\n\n  @GetMapping(\"/{id}\")\n  fun findById(@PathVariable id: Long) = repository.findById(id)\n\n  @PostMapping\n  @ResponseStatus(HttpStatus.CREATED)\n  fun save(@RequestBody user: User) = repository.save(user)\n\n  @PutMapping(\"/{id}\")\n  @ResponseStatus(HttpStatus.NO_CONTENT)\n  fun update(@RequestBody user: User, @PathVariable id: Long) = repository.findById(id).ifPresent {\n    repository.save(user.copy(id = id))\n  }\n\n  @DeleteMapping(\"/{id}\")\n  @ResponseStatus(HttpStatus.NO_CONTENT)\n  fun deleteById(@PathVariable id: Long) = repository.deleteById(id)\n}\n\n```\n\n![](https://storage.googleapis.com/zenn-user-upload/tj6uhanz06ac6rv8n1c8hs4lawzl)\n\nおー簡単。。。\nここでエントリポイントに普通にcreate文作ればもうlocalhost叩けばデータが見れる。\n\nさてここで`data class`というものに着目してみる。\nこれはclassとは違くて、色々便利機能がついたものらしいけどよくわからない。\nよくわからないので、kotlinのdata classをjavaにコンパイルして、classと違ってどんなものが追加されてるのか見てみる。\n\nkotlincでコンパイルした後、JVM bytecodeになったファイルを、javaにfernflowelでdecompileしてあげればいい。\n```kotlin\ndata class User(\n  val id: Long = 0,\n  val name: String = \"\"\n)\n```\n\n→　kotlinc test.ktでUser.classというJVM Bytecodeが爆誕する\n→　こいつ↓をfernflowerでdecompileする。fernflowerはこいつをビルドする（ここらへん単体binが無いのはJVM系の辛いところな気がする。これ超重いし・・・）\n\nhttps://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine\n\nちなみにこのintellijにバグがあったのでPRした。\nhttps://github.com/JetBrains/intellij-community/pull/1523\n\n- `intellij-community/plugins/java-decompiler/engine/`でgradlew buildしたのち、build/libsにはかれたfernflowerをjar指定して逆コンパイルすると。。。できあがったのがこれ\n\nhttps://gist.github.com/ulwlu/09151d53c53318b00b627a2f071663b3\n\nうおーーー、4行が106行になった。滅茶苦茶追加されてる。\nデータを持つだけのクラスという定義なので、色々と普通のクラスと勝手も違う。\n\n- equals() : 同一インスタンスか、ではなく同じプロパティを持っているかどうか\n- copy(): 同一プロパティを持ったインスタンスをコピーする\n- componentN(): これ筋が良いのかはわからないんだけど内部プロパティに定義順にアクセスできる \n- 分解宣言ができる: (id, name) = User1みたいな。pythonに似てる。\n\n\n"
    },
    {
      "author": "ulwlu",
      "created_at": "2021-03-08",
      "body_updated_at": "2021-03-08",
      "body_markdown": "ちょっとここで軽くbeansの概念が出てきたから整理。\n\n- jave beans: 特定のコーディングルールに則ってるだけのただのJavaクラス。引数なしコンストラクタがあって、getter setterのみでプロパティへのアクセスを許可していて、Serializableに実装される。これの何がいいのかというと「データを保持するだけの箱」としてのオブジェクトがDTOとかに必要とされたからできた（読み書きできるプロパティを限定できるし、書き込み時の制御もできるし）。それの再利用性の高さが発展して、Swingとかみたいにコンポーネントのような大きな役割を持つようになった。\n- Spring Bean: java beansとは限らない。serializeで実装してないしコンストラクタに引数があったりする。アノテーションで簡単に実装できるし（serializableをimportしてimplementsして、更に宣言やコンストラクタやsetter getter全部書かないといけなかった）Springではこちらがデファクタ(Spring bootが無い時代はSpringも地獄だったらしい。xmlにbean定義を書いていかないといけない為)。@Beanで登録すればDIコンテナに勝手に登録されるので、このクラスが必要になった時は@Autowired宣言すれば依存注入を好きな時にできて便利。これだけ見ると、こっちのBeanは「**任意のpublic classをインスタンス化して、それをDIコンテナに登録する**」という意図の方があーってわかるような気がする。\n\n"
    }
  ]
}